---
author: [[Elijah ben Izzy]]
title: "How Well-Structured Should Your Data Code Be?"
date: 2024-02-03
tags: 
- articles
- literature-note
---
![rw-book-cover](https://substackcdn.com/image/fetch/w_1200,h_600,c_fill,f_jpg,q_auto:good,fl_progressive:steep,g_auto/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F494ed180-8641-4d0f-8e29-e01ee34f2671_582x502.png)

## Metadata
- Author: [[Elijah ben Izzy]]
- Full Title: How Well-Structured Should Your Data Code Be?
- URL: https://blog.dagworks.io/p/how-well-structured-should-your-data

## Highlights
- A good data scientist is focused solely on maximizing value for their organization, and thus is delicately balancing conducting new analyses, exploring new spaces, managing relationships with multiple product teams, and integrating new datasets. There just isn’t enough time in the day to do all that while *also* building good code ([View Highlight](https://read.readwise.io/read/01hnr6ryqt56p6s9eywgpc2wem))
- ![](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F56903c9b-bb9c-4a42-8fae-9e664744aa19_501x434.png) ([View Highlight](https://read.readwise.io/read/01hnr6sffc2kr0nnz3ryn2cd12))
- Add value, move quickly, build a good system — pick 2. And you have to *Add Value* ([View Highlight](https://read.readwise.io/read/01hnr6sjhs6446j59jenh92t3x))
- If they care about their job, adding value is not only a requirement, but also a reward-lever. Thus the trade-off is between “move quickly”, and “build a good system”. Problematically, as discussed above, the failure to build a good system will, over time, cause even the best data scientists/engineers to eventually slow down. ([View Highlight](https://read.readwise.io/read/01hnr6t4x8njznkpj584x3agff))
- This forms a dilemma that is crucial to the understanding of how and why data teams need platforms to function effectively. We started this post by presenting this dilemma. We will then concretize properties of a “good” ML system, present a mental model to think about the trade-off, talk about how employing a platform mindset can make it less of a trade-off, and share how the open source platform we’re building at DAGWorks attempts to address these concerns. ([View Highlight](https://read.readwise.io/read/01hnr6te10snd6zefazaxsj513))
- While multiple professionals may disagree on this question, we will answer it in relation to the trade-off above. *At a high level, a good system will not make you hate your colleague (or your previous self) when you work on it.* OK, that’s nebulous. What do we mean, specifically? Note that these are not addressing the quality of the ML itself, only the quality of the code/infrastructure: ([View Highlight](https://read.readwise.io/read/01hnr6tt0rxnw44x2qfvyh5mwa))
- **A good system does not break (often)**. While *never* breaking is aspirational (and, practically impossible), adequate fallbacks as well as a good story for testing changes make failure a tail risk, rather than a daily event. ([View Highlight](https://read.readwise.io/read/01hnr6tw5d68k5bkddm2tmm0nt))
- **A good system is easy to triage/debug.** If you’re woken up in the middle of the night due to a broken ETL/web-service, you want to quickly figure out what part of the system is the cause/trigger. When you’ve identified the source, you need to be able to quickly fix it. ([View Highlight](https://read.readwise.io/read/01hnr6v0mrr1svrjhm63cp97j0))
- **A good system is easy to understand**. When you want to share what you’ve built with a colleague, determine the scope of a change you’re planning, or brush up on your knowledge of your code for analysis, you want to be able to quickly understand a system. While documentation is important, it is second to *inherent readability*, which requires *simplicity* and *structure.* ([View Highlight](https://read.readwise.io/read/01hnr6v5kje04ta33j6hs6y2p8))
- **A good system is easy to modify**. [I may have a bridge to sell you](https://nycwalks.com/blog/the-brooklyn-bridge-if-you-believe-that-i-have-a-bridge-in-brooklyn-to-sell-to-you/) if you genuinely believe that any code you write will be shipped to production, used, and never touched again. Not only will you have to routinely identify and fix bugs, iterate on the modeling techniques, and iron out assumptions that you (intentionally or unintentionally) made when building it, but you will also have to make larger changes. With any degree of success, you will likely be required to repurpose your system with new data sources, scale it to new use-cases, or even build a new system that shares elements of the current one. ([View Highlight](https://read.readwise.io/read/01hnr6vktq267b15rd99jyrjew))
- ![](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F1295296c-7793-46a3-9fe3-f7aa0313add5_1176x1019.png) ([View Highlight](https://read.readwise.io/read/01hnr6wsq3h5sm7brjbm71yr4k))
- ![](https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F1295296c-7793-46a3-9fe3-f7aa0313add5_1176x1019.png) ([View Highlight](https://read.readwise.io/read/01hnr6wsr0zhh96g4jnxvh5vka))
- So, as a first question when determining how to structure your code for production, you should ask yourself: *Am I working along the efficient frontier?* Another way of thinking about this is, *for the required level of system quality, could I be moving any faster*? And *for the speed that I’m moving at, could I be building a better system?* If the answer is yes, you could be moving faster, or yes, you could be building a better system, then you have no excuse. You *should* be moving faster.[2](https://blog.dagworks.io/p/how-well-structured-should-your-data#footnote-2-140336523) ([View Highlight](https://read.readwise.io/read/01hnr6x3v4pzkgg0w7cn6ywjwa))
- Let us put on our *platform team* hat for a bit. While you may not have a team to build a platform for you, you will inevitably wear the platform engineer hat multiple times in your career, e.g. building tools for yourself and others. How do you approach doing this? A platform mindset is less opinionated about *where* you reside along the curve (within reason, that is), than (A) concerned about ensuring you have the information you need to build at any point along the efficient frontier (rather than within it) and (B) focused on improving the curve itself to allow for more optimal results that require less of a trade-off. ([View Highlight](https://read.readwise.io/read/01hnr6xzjd81na1gzbera46zz5))
- **(A) in the image** is largely the job of evangelizing technology and bringing yourself and others up to speed (documentation, presentation, and socialization are all critical skills – see [our post](https://blog.dagworks.io/p/winning-hearts-and-minds-at-work) on the ADKAR method for change management for a detailed guide). **(B) in the image** involves building new capabilities/toolsets, as well as understanding workflows/*which* tool sets to build. Also, note the shape of the new curve – it is intentionally less of a curve, and more of a right angle. This means that the trade-offs are less considerable. In a world with an ideal platform, building code to last requires far less of a sacrifice in speed-to-production, or perhaps none at all. ([View Highlight](https://read.readwise.io/read/01hnr6yqwmp5vwxm48zbg29e9z))
- **A good system does not break (often)**. As dataflows in Hamilton consist of python functions, it is easy to build unit tests for simple logic. Furthermore, it is easy to build integration tests for more complex logic/chains of functions. Mocking is done by data injection, rather than complex mocking libraries. ([View Highlight](https://read.readwise.io/read/01hnr76xgg6r4kgnay05j7wshy))
- **A good system is easy to triage/debug.** Any error can be traced to an individual function, which is named according to its role in the final result. If data looks weird, Hamilton functions provide easy introspection on output data/dependencies, so you can trace the source of the data up the DAG scientifically. Hamilton also supports [runtime data quality checks](http://runtime data quality checks) that are extensible, so you can fail quickly if data assumptions are invalidated. In most other systems, figuring out why data is weird is a near-herculean task. ([View Highlight](https://read.readwise.io/read/01hnr770fky7q3xzf52px7av47))
- **A good system is easy to understand**. Hamilton provides multiple benefits here – functions are self-documenting so you can understand the inputs to any output variable simply by looking at the code. Furthermore, Hamilton has a sophisticated visualization capability that allows you to track lineage and understand execution plans. As more individuals in an organization adopt Hamilton, the effects of standardization naturally result in a network effect that makes each subsequent pipeline easier to read and manage. ([View Highlight](https://read.readwise.io/read/01hnr773mvyzya5ddxh3x6kpgj))
- **A good system is easy to modify**. Making and understanding changes is trivial. Changes in Hamilton are inherently targeted to specific functions, allowing you to isolate and test the desired effect. Furthermore, functions are naturally broken into modules, which encourage reuse and composition. ([View Highlight](https://read.readwise.io/read/01hnr777yh45atqm5f7g0pdnk1))
- You might be wondering *I like all these benefits, but don’t I have to learn a new system? And won’t that make me slower?* Yes, you do have to learn a new system, but as we showed above, it’s just python functions! Furthermore, there’s a trick – you don’t always have to use Hamilton to its fullest extent. **Hamilton supports multiple points along the efficient frontier between good code and quick development**, **and makes it easier to move along that curve**. Let’s make this more concrete by looking at some different goals for getting data projects to production: ([View Highlight](https://read.readwise.io/read/01hnr77n55v5kp2txn6pjbwjpq))

---
author: [[Lilian Weng]]
title: "LLM Powered Autonomous Agents"
date: 2024-06-03
tags: 
- articles
- literature-note
---
![rw-book-cover](https://lilianweng.github.io/favicon-32x32.png)

## Metadata
- Author: [[Lilian Weng]]
- Full Title: LLM Powered Autonomous Agents
- URL: https://lilianweng.github.io/posts/2023-06-23-agent/

## Highlights
- In a LLM-powered autonomous agent system, LLM functions as the agent’s brain, complemented by several key components:
  • **Planning**
  • Subgoal and decomposition: The agent breaks down large tasks into smaller, manageable subgoals, enabling efficient handling of complex tasks.
  • Reflection and refinement: The agent can do self-criticism and self-reflection over past actions, learn from mistakes and refine them for future steps, thereby improving the quality of final results.
  • **Memory**
  • Short-term memory: I would consider all the in-context learning (See [Prompt Engineering](https://lilianweng.github.io/posts/2023-03-15-prompt-engineering/)) as utilizing short-term memory of the model to learn.
  • Long-term memory: This provides the agent with the capability to retain and recall (infinite) information over extended periods, often by leveraging an external vector store and fast retrieval.
  • **Tool use**
  • The agent learns to call external APIs for extra information that is missing from the model weights (often hard to change after pre-training), including current information, code execution capability, access to proprietary information sources and more.
  ![](https://lilianweng.github.io/posts/2023-06-23-agent/agent-overview.png) ([View Highlight](https://read.readwise.io/read/01hz9nbpq0mhz6b3v1s28zd4zs))
- Component One: Planning[#](https://lilianweng.github.io/posts/2023-06-23-agent#component-one-planning)
  A complicated task usually involves many steps. An agent needs to know what they are and plan ahead. ([View Highlight](https://read.readwise.io/read/01hz9ne4tqqwfda5nz9j1yyk61))
- Task Decomposition[#](https://lilianweng.github.io/posts/2023-06-23-agent#task-decomposition)
  [**Chain of thought**](https://lilianweng.github.io/posts/2023-03-15-prompt-engineering/#chain-of-thought-cot) (CoT; [Wei et al. 2022](https://arxiv.org/abs/2201.11903)) has become a standard prompting technique for enhancing model performance on complex tasks. The model is instructed to “think step by step” to utilize more test-time computation to decompose hard tasks into smaller and simpler steps. CoT transforms big tasks into multiple manageable tasks and shed lights into an interpretation of the model’s thinking process.
  **Tree of Thoughts** ([Yao et al. 2023](https://arxiv.org/abs/2305.10601)) extends CoT by exploring multiple reasoning possibilities at each step. It first decomposes the problem into multiple thought steps and generates multiple thoughts per step, creating a tree structure. The search process can be BFS (breadth-first search) or DFS (depth-first search) with each state evaluated by a classifier (via a prompt) or majority vote.
  Task decomposition can be done (1) by LLM with simple prompting like `"Steps for XYZ.\n1."`, `"What are the subgoals for achieving XYZ?"`, (2) by using task-specific instructions; e.g. `"Write a story outline."` for writing a novel, or (3) with human inputs.
  Another quite distinct approach, **LLM+P** ([Liu et al. 2023](https://arxiv.org/abs/2304.11477)), involves relying on an external classical planner to do long-horizon planning. This approach utilizes the Planning Domain Definition Language (PDDL) as an intermediate interface to describe the planning problem. In this process, LLM (1) translates the problem into “Problem PDDL”, then (2) requests a classical planner to generate a PDDL plan based on an existing “Domain PDDL”, and finally (3) translates the PDDL plan back into natural language. Essentially, the planning step is outsourced to an external tool, assuming the availability of domain-specific PDDL and a suitable planner which is common in certain robotic setups but not in many other domains. ([View Highlight](https://read.readwise.io/read/01hz9nesfsdwfd4aqmtbdp8sy6))
- Self-Reflection[#](https://lilianweng.github.io/posts/2023-06-23-agent#self-reflection)
  Self-reflection is a vital aspect that allows autonomous agents to improve iteratively by refining past action decisions and correcting previous mistakes. It plays a crucial role in real-world tasks where trial and error are inevitable.
  **ReAct** ([Yao et al. 2023](https://arxiv.org/abs/2210.03629)) integrates reasoning and acting within LLM by extending the action space to be a combination of task-specific discrete actions and the language space. The former enables LLM to interact with the environment (e.g. use Wikipedia search API), while the latter prompting LLM to generate reasoning traces in natural language.
  The ReAct prompt template incorporates explicit steps for LLM to think, roughly formatted as:
  Thought: ...
  Action: ...
  Observation: ...
  ... (Repeated many times)
  ![](https://lilianweng.github.io/posts/2023-06-23-agent/react.png) ([View Highlight](https://read.readwise.io/read/01hz9nezw9nq41dxs83xyjaxdv))
- **Reflexion** ([Shinn & Labash 2023](https://arxiv.org/abs/2303.11366)) is a framework to equips agents with dynamic memory and self-reflection capabilities to improve reasoning skills. Reflexion has a standard RL setup, in which the reward model provides a simple binary reward and the action space follows the setup in ReAct where the task-specific action space is augmented with language to enable complex reasoning steps. After each action at, the agent computes a heuristic ht and optionally may *decide to reset* the environment to start a new trial depending on the self-reflection results.
  ![](https://lilianweng.github.io/posts/2023-06-23-agent/reflexion.png)
  Fig. 3. Illustration of the Reflexion framework. (Image source: [Shinn & Labash, 2023](https://arxiv.org/abs/2303.11366)) ([View Highlight](https://read.readwise.io/read/01hz9ngdxwtg358c6ap8sgzzd4))
## New highlights added June 4, 2024 at 8:54 AM
- **Reflexion** ([Shinn & Labash 2023](https://arxiv.org/abs/2303.11366)) is a framework to equips agents with dynamic memory and self-reflection capabilities to improve reasoning skills. Reflexion has a standard RL setup, in which the reward model provides a simple binary reward and the action space follows the setup in ReAct where the task-specific action space is augmented with language to enable complex reasoning steps. After each action at, the agent computes a heuristic ht and optionally may *decide to reset* the environment to start a new trial depending on the self-reflection results.
  ![](https://lilianweng.github.io/posts/2023-06-23-agent/reflexion.png)
  Fig. 3. Illustration of the Reflexion framework. (Image source: [Shinn & Labash, 2023](https://arxiv.org/abs/2303.11366)) ([View Highlight](https://read.readwise.io/read/01hzgz3yttenbga2z1956s1fhq))
- The heuristic function determines when the trajectory is inefficient or contains hallucination and should be stopped. Inefficient planning refers to trajectories that take too long without success. Hallucination is defined as encountering a sequence of consecutive identical actions that lead to the same observation in the environment ([View Highlight](https://read.readwise.io/read/01hzgz46fa3ndetr9h8n3v1v8d))
- The idea of CoH is to present a history of sequentially improved outputs in context and train the model to take on the trend to produce better outputs. **Algorithm Distillation** (AD; [Laskin et al. 2023](https://arxiv.org/abs/2210.14215)) applies the same idea to cross-episode trajectories in reinforcement learning tasks, where an *algorithm* is encapsulated in a long history-conditioned policy. Considering that an agent interacts with the environment many times and in each episode the agent gets a little better, AD concatenates this learning history and feeds that into the model. Hence we should expect the next predicted action to lead to better performance than previous trials. The goal is to learn the process of RL instead of training a task-specific policy itself.
  ![](https://lilianweng.github.io/posts/2023-06-23-agent/algorithm-distillation.png)
  Fig. 6. Illustration of how Algorithm Distillation (AD) works. 
  (Image source: [Laskin et al. 2023](https://arxiv.org/abs/2210.14215)). ([View Highlight](https://read.readwise.io/read/01hzgz5x14t1w7aa73vd214y5d))
- The paper hypothesizes that any algorithm that generates a set of learning histories can be distilled into a neural network by performing behavioral cloning over actions. The history data is generated by a set of source policies, each trained for a specific task. At the training stage, during each RL run, a random task is sampled and a subsequence of multi-episode history is used for training, such that the learned policy is task-agnostic.
  In reality, the model has limited context window length, so episodes should be short enough to construct multi-episode history. Multi-episodic contexts of 2-4 episodes are necessary to learn a near-optimal in-context RL algorithm. The emergence of in-context RL requires long enough context. ([View Highlight](https://read.readwise.io/read/01hzgz6ygdp1zepm694z5y1qcf))
- Types of Memory[#](https://lilianweng.github.io/posts/2023-06-23-agent#types-of-memory)
  Memory can be defined as the processes used to acquire, store, retain, and later retrieve information. There are several types of memory in human brains.
  1. **Sensory Memory**: This is the earliest stage of memory, providing the ability to retain impressions of sensory information (visual, auditory, etc) after the original stimuli have ended. Sensory memory typically only lasts for up to a few seconds. Subcategories include iconic memory (visual), echoic memory (auditory), and haptic memory (touch).
  2. **Short-Term Memory** (STM) or **Working Memory**: It stores information that we are currently aware of and needed to carry out complex cognitive tasks such as learning and reasoning. Short-term memory is believed to have the capacity of about 7 items ([Miller 1956](https://lilianweng.github.io/posts/2023-06-23-agent/psychclassics.yorku.ca/Miller/)) and lasts for 20-30 seconds.
  3. **Long-Term Memory** (LTM): Long-term memory can store information for a remarkably long time, ranging from a few days to decades, with an essentially unlimited storage capacity. There are two subtypes of LTM:
  • Explicit / declarative memory: This is memory of facts and events, and refers to those memories that can be consciously recalled, including episodic memory (events and experiences) and semantic memory (facts and concepts).
  • Implicit / procedural memory: This type of memory is unconscious and involves skills and routines that are performed automatically, like riding a bike or typing on a keyboard. ([View Highlight](https://read.readwise.io/read/01hzgz7kwa8qexaxsy89g2r5de))
- We can roughly consider the following mappings:
  • Sensory memory as learning embedding representations for raw inputs, including text, image or other modalities;
  • Short-term memory as in-context learning. It is short and finite, as it is restricted by the finite context window length of Transformer.
  • Long-term memory as the external vector store that the agent can attend to at query time, accessible via fast retrieval. ([View Highlight](https://read.readwise.io/read/01hzgz7x0c3af2bgk7qnpdxnjv))
- Maximum Inner Product Search (MIPS)[#](https://lilianweng.github.io/posts/2023-06-23-agent#maximum-inner-product-search-mips)
  The external memory can alleviate the restriction of finite attention span. A standard practice is to save the embedding representation of information into a vector store database that can support fast maximum inner-product search ([MIPS](https://en.wikipedia.org/wiki/Maximum_inner-product_search)). To optimize the retrieval speed, the common choice is the *approximate nearest neighbors (ANN)​* algorithm to return approximately top k nearest neighbors to trade off a little accuracy lost for a huge speedup. ([View Highlight](https://read.readwise.io/read/01hzgz998svj6cec754qcg99s2))
- **MRKL** ([Karpas et al. 2022](https://arxiv.org/abs/2205.00445)), short for “Modular Reasoning, Knowledge and Language”, is a neuro-symbolic architecture for autonomous agents. A MRKL system is proposed to contain a collection of “expert” modules and the general-purpose LLM works as a router to route inquiries to the best suitable expert module. These modules can be neural (e.g. deep learning models) or symbolic (e.g. math calculator, currency converter, weather API).
  They did an experiment on fine-tuning LLM to call a calculator, using arithmetic as a test case. Their experiments showed that it was harder to solve verbal math problems than explicitly stated math problems because LLMs (7B Jurassic1-large model) failed to extract the right arguments for the basic arithmetic reliably. The results highlight when the external symbolic tools can work reliably, *knowing when to and how to use the tools are crucial*, determined by the LLM capability. ([View Highlight](https://read.readwise.io/read/01hzgzabb5k1j3ejc82tbyy3kr))
- Both **TALM** (Tool Augmented Language Models; [Parisi et al. 2022](https://arxiv.org/abs/2205.12255)) and **Toolformer** ([Schick et al. 2023](https://arxiv.org/abs/2302.04761)) fine-tune a LM to learn to use external tool APIs. The dataset is expanded based on whether a newly added API call annotation can improve the quality of model outputs. See more details in the [“External APIs” section](https://lilianweng.github.io/posts/2023-03-15-prompt-engineering/#external-apis) of Prompt Engineering.
  ChatGPT [Plugins](https://openai.com/blog/chatgpt-plugins) and OpenAI API [function calling](https://platform.openai.com/docs/guides/gpt/function-calling) are good examples of LLMs augmented with tool use capability working in practice. The collection of tool APIs can be provided by other developers (as in Plugins) or self-defined (as in function calls). ([View Highlight](https://read.readwise.io/read/01hzgzan91hj3884p9xen2mt53))
- **HuggingGPT** ([Shen et al. 2023](https://arxiv.org/abs/2303.17580)) is a framework to use ChatGPT as the task planner to select models available in HuggingFace platform according to the model descriptions and summarize the response based on the execution results.
  ![](https://lilianweng.github.io/posts/2023-06-23-agent/hugging-gpt.png)
  Fig. 11. Illustration of how HuggingGPT works. (Image source: [Shen et al. 2023](https://arxiv.org/abs/2303.17580)) ([View Highlight](https://read.readwise.io/read/01hzgzat0b0pskmx2wm1ha1fsx))
- **(1) Task planning**: LLM works as the brain and parses the user requests into multiple tasks. There are four attributes associated with each task: task type, ID, dependencies, and arguments. They use few-shot examples to guide LLM to do task parsing and planning. ([View Highlight](https://read.readwise.io/read/01hzgzb8q291c7pw2tsmp5g75x))
- **(2) Model selection**: LLM distributes the tasks to expert models, where the request is framed as a multiple-choice question. LLM is presented with a list of models to choose from. Due to the limited context length, task type based filtration is needed. ([View Highlight](https://read.readwise.io/read/01hzgzbg17qdby16yrz65nwxb1))
- **(3) Task execution**: Expert models execute on the specific tasks and log results. ([View Highlight](https://read.readwise.io/read/01hzgzcddg3nbmx7hgqbvf01f1))
- **(4) Response generation**: LLM receives the execution results and provides summarized results to users. ([View Highlight](https://read.readwise.io/read/01hzgzcga0gw9a5g1726w2my6v))
- In the API-Bank workflow, LLMs need to make a couple of decisions and at each step we can evaluate how accurate that decision is. Decisions include:
  1. Whether an API call is needed.
  2. Identify the right API to call: if not good enough, LLMs need to iteratively modify the API inputs (e.g. deciding search keywords for Search Engine API).
  3. Response based on the API results: the model can choose to refine and call again if results are not satisfied. ([View Highlight](https://read.readwise.io/read/01hzgze5merjbmsrwmb3af9rbn))
- **ChemCrow** ([Bran et al. 2023](https://arxiv.org/abs/2304.05376)) is a domain-specific example in which LLM is augmented with 13 expert-designed tools to accomplish tasks across organic synthesis, drug discovery, and materials design. The workflow, implemented in [LangChain](https://github.com/hwchase17/langchain), reflects what was previously described in the [ReAct](https://lilianweng.github.io/posts/2023-06-23-agent#react) and [MRKLs](https://lilianweng.github.io/posts/2023-06-23-agent#mrkl) and combines CoT reasoning with tools relevant to the tasks:
  • The LLM is provided with a list of tool names, descriptions of their utility, and details about the expected input/output.
  • It is then instructed to answer a user-given prompt using the tools provided when necessary. The instruction suggests the model to follow the ReAct format - `Thought, Action, Action Input, Observation`. ([View Highlight](https://read.readwise.io/read/01hzgzeq46w50rfacht38xhtb6))
- One interesting observation is that while the LLM-based evaluation concluded that GPT-4 and ChemCrow perform nearly equivalently, human evaluations with experts oriented towards the completion and chemical correctness of the solutions showed that ChemCrow outperforms GPT-4 by a large margin. This indicates a potential problem with using LLM to evaluate its own performance on domains that requires deep expertise. The lack of expertise may cause LLMs not knowing its flaws and thus cannot well judge the correctness of task results. ([View Highlight](https://read.readwise.io/read/01hzgzfmhbnhgjmvek4dy64v6z))
- **Generative Agents** ([Park, et al. 2023](https://arxiv.org/abs/2304.03442)) is super fun experiment where 25 virtual characters, each controlled by a LLM-powered agent, are living and interacting in a sandbox environment, inspired by The Sims. Generative agents create believable simulacra of human behavior for interactive applications. ([View Highlight](https://read.readwise.io/read/01hzgzg8dj2s9e7w7bgwam86cm))
- [AutoGPT](https://github.com/Significant-Gravitas/Auto-GPT) has drawn a lot of attention into the possibility of setting up autonomous agents with LLM as the main controller. It has quite a lot of reliability issues given the natural language interface, but nevertheless a cool proof-of-concept demo. A lot of code in AutoGPT is about format parsing. ([View Highlight](https://read.readwise.io/read/01hzgzgh0z7crxh07c9dm43ajb))
- [GPT-Engineer](https://github.com/AntonOsika/gpt-engineer) is another project to create a whole repository of code given a task specified in natural language. The GPT-Engineer is instructed to think over a list of smaller components to build and ask for user input to clarify questions as needed. ([View Highlight](https://read.readwise.io/read/01hzgzgxq30e5de559e796r0a5))
- Challenges[#](https://lilianweng.github.io/posts/2023-06-23-agent#challenges)
  After going through key ideas and demos of building LLM-centered agents, I start to see a couple common limitations:
  • **Finite context length**: The restricted context capacity limits the inclusion of historical information, detailed instructions, API call context, and responses. The design of the system has to work with this limited communication bandwidth, while mechanisms like self-reflection to learn from past mistakes would benefit a lot from long or infinite context windows. Although vector stores and retrieval can provide access to a larger knowledge pool, their representation power is not as powerful as full attention.
  • **Challenges in long-term planning and task decomposition**: Planning over a lengthy history and effectively exploring the solution space remain challenging. LLMs struggle to adjust plans when faced with unexpected errors, making them less robust compared to humans who learn from trial and error.
  • **Reliability of natural language interface**: Current agent system relies on natural language as an interface between LLMs and external components such as memory and tools. However, the reliability of model outputs is questionable, as LLMs may make formatting errors and occasionally exhibit rebellious behavior (e.g. refuse to follow an instruction). Consequently, much of the agent demo code focuses on parsing model output. ([View Highlight](https://read.readwise.io/read/01hzgzhe42qsb9j19f7bqy90cz))

---
author: [[huggingface.co]]
title: "Fine-Tuning Florence-2 - Microsoft&#39;s Cutting-Edge Vision Language Models"
date: 2024-06-26
tags: 
- articles
- literature-note
---
![rw-book-cover](https://huggingface.co/blog/assets/182_finetune-florence/thumbnail.png)

## Metadata
- Author: [[huggingface.co]]
- Full Title: Fine-Tuning Florence-2 - Microsoft's Cutting-Edge Vision Language Models
- URL: https://huggingface.co/blog/finetune-florence2

## Highlights
- Florence-2, released by Microsoft in June 2024, is a foundation vision-language model. This model is very attractive because of its small size (0.2B and 0.7B) and strong performance on a variety of computer vision and vision-language tasks. ([View Highlight](https://read.readwise.io/read/01j1a8q613repcxqnxkpmv11ht))
- Florence supports many tasks out of the box: captioning, object detection, OCR, and more. However, your task or domain might not be supported, or you may want to better control the model's output for your task. That's when you will need to fine-tune. ([View Highlight](https://read.readwise.io/read/01j1a8qc5gqw7n7m0897cz19fc))
- Regardless of the computer vision task being performed, Florence-2 formulates the problem as a sequence-to-sequence task. Florence-2 takes an image and text as inputs, and generates text as output. The model has a simple structure. It uses a DaViT vision encoder to convert images into visual embeddings, and BERT to convert text prompts into text and location embeddings. The resulting embeddings are then processed by a standard encoder-decoder transformer architecture, generating text and location tokens. ([View Highlight](https://read.readwise.io/read/01j1a8smtm5yy9y5aks8wkp9qq))
- Florence-2's strength doesn't stem from its architecture, but from the massive dataset it was pre-trained on. The authors noted that leading computer vision datasets typically contain limited information - WIT only includes image/caption pairs, [SA-1B](https://ai.meta.com/datasets/segment-anything/) only contains images and associated segmentation masks. Therefore, they decided to build a new FLD-5B dataset containing a wide range of information about each image - boxes, masks, captions, and grounding. The dataset creation process was largely automated. The authors used off-the-shelf task-specific models and a set of heuristics and quality checks to clean the obtained results. The result was a new dataset containing over 5 billion annotations for 126 million images, which was used to pre-train the Florence-2 model. ([View Highlight](https://read.readwise.io/read/01j1a8spay00w3y1c87wbbrt5f))
- We experimented with various methods to adapt the model for VQA (Visual Question Answering) responses. The most effective approach we found was region-to-description prompting, though it doesn't fully align with VQA tasks. Captioning provides descriptive information about the image but doesn't allow for direct question input. We also tested several "unsupported" prompts such as " <VQA>", "<vqa>", and "<Visual question answering>". Unfortunately, these attempts yielded unusable results. ([View Highlight](https://read.readwise.io/read/01j1a8t7t55xg2qse34kcx6fc0))
- We measure performance using the [Levenshtein's similarity](https://en.wikipedia.org/wiki/Levenshtein_distance), the standard metric for the DocVQA dataset. Before fine-tuning, the similarity between the model's predictions and the ground truth on the validation dataset was 0, as the outputs were not close to the ground truth. After fine-tuning with the training set for seven epochs, the similarity score on the validation set improved to 57.0. ([View Highlight](https://read.readwise.io/read/01j1a8tp0szxffgbdz8t3kj83f))
- While the model performs well for DocVQA, there is room for improvement in general document understanding. However, it successfully completes the tasks, showcasing Florence-2's potential for fine-tuning on downstream tasks. To develop an exceptional VQA model, we recommend further fine-tuning Florence-2 using[The Cauldron](https://huggingface.co/datasets/HuggingFaceM4/the_cauldron). ([View Highlight](https://read.readwise.io/read/01j1a8v0m7hx3fkxmxf2k20tkj))
- For pre-training, the authors used a batch size of 2048 for the base model and 3072 for the large one. They also describe a performance improvement when fine-tuning with an unfrozen image encoder, compared with freezing it. ([View Highlight](https://read.readwise.io/read/01j1a8wcs2r405a3ct33h782g3))
- We conducted our experiments with a much lower resource setup, to explore what the model would be capable of in more constrained fine-tuning environments. We froze the vision encoder and used a batch size of 6 on a single A100 GPU in [Colab](https://colab.research.google.com/drive/1hKDrJ5AH_o7I95PtZ9__VlCTNAo1Gjpf?usp=sharing), or a batch size of 1 with a T4. In parallel, we conducted an experiment with more resources, fine-tuning the entire model with a batch size of 64. This training process took 70 minutes on a cluster equipped with 8 H100 GPUs. This trained model can be [found here](https://huggingface.co/HuggingFaceM4/Florence-2-DocVQA). ([View Highlight](https://read.readwise.io/read/01j1a8xgw0y1jgb2wgksnc5db3))
- In every case, we found a small learning rate of 1e-6 to be beneficial for training. With larger learning rates the model will quickly overfit the training set. ([View Highlight](https://read.readwise.io/read/01j1a8xkrcc6m3essn6303cv3n))
- We can load the model and processor using the `AutoModelForCausalLM` and `AutoProcessor` classes from the transformers library. We need to pass `trust_remote_code=True` because the model uses custom code â€“ it has not been natively integrated into transformers yet. We will also freeze the vision encoder to make fine-tuning less expensive. ([View Highlight](https://read.readwise.io/read/01j1a8y3j8fy8k6jbrpeewntte))
- Let's now fine-tune the model! We'll build a training PyTorch Dataset in which we'll prepend a <DocVQA> prefix to each question from the dataset. ([View Highlight](https://read.readwise.io/read/01j1a8yesqvn1bram4xz863az7))
- We'll now build the data collator that builds training batches from the dataset samples, and start training. In A100 with 40GB memory, we can fit in 6 examples. If you're training on T4, you can use a batch size of 1. ([View Highlight](https://read.readwise.io/read/01j1a8ysz0tnhzppskwtd7e7y0))
- In this post, we showed that Florence-2 can be effectively fine-tuned to a custom dataset, achieving impressive performance on a completely new task in a short amount of time. This capability is particularly valuable for those looking to deploy this small model on devices or use it cost-effectively in production environments. We encourage the open-source community to leverage this fine-tuning tutorial and explore the remarkable potential of Florence-2 for a wide range of new tasks! We can't wait to see your models on the ðŸ¤— Hub! ([View Highlight](https://read.readwise.io/read/01j1a9xz310q5250ryngddw77k))

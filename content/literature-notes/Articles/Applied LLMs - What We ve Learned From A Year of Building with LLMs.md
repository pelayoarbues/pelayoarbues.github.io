---
author: [[Eugene Yan, Bryan Bischof, Charles Frye, Hamel Husain, Jason Liu, Shreya Shankar]]
title: "Applied LLMs - What We ve Learned From A Year of Building with LLMs"
date: 2024-06-09
tags: 
- articles
- literature-note
---
![rw-book-cover](https://readwise-assets.s3.amazonaws.com/media/reader/parsed_document_assets/182552986/EY8CXfPDMKnrVpxTPvNDBzKGBeTgFxqTC8WmMYrYazA-cove_wOL04jV.png)

## Metadata
- Author: [[Eugene Yan, Bryan Bischof, Charles Frye, Hamel Husain, Jason Liu, Shreya Shankar]]
- Full Title: Applied LLMs - What We ve Learned From A Year of Building with LLMs
- URL: https://readwise.io/reader/document_raw_content/182552986

## Highlights
- A key challenge when working with LLMs is that they’ll often generate output even when they shouldn’t. This can lead to harmless but nonsensical responses, or more egregious defects like toxicity or dangerous content. ([View Highlight](https://read.readwise.io/read/01hzzdg4b720wx2v53cbhp7vdr))
- While we can try to prompt the LLM to return a “not applicable” or “unknown” response, it’s not foolproof. Even when the log probabilities are available, they’re a poor indicator of output quality. While log probs indicate the likelihood of a token appearing in the output, they don’t necessarily rehect the correctness of the generated text. On the contrary, for instruction-tuned models that are trained to answer queries and generate coherent responses, log probabilities may not be well-calibrated. Thus, while a high log probability may indicate that the output is huent and coherent, it doesn’t mean it’s accurate or relevant. ([View Highlight](https://read.readwise.io/read/01hzzdgjccxwk3nzaz7338bgyj))
- Unlike content safety or PII defects which have a lot of attention and thus seldom occur, factual inconsistencies are stubbornly persistent and more challenging to detect. They’re more common and occur at a baseline rate of 5 - 10%, and from what we’ve learned from LLM providers, it can be challenging to get it below 2%, even on simple tasks such as summarization. ([View Highlight](https://read.readwise.io/read/01hzzdkzvvtrz22hfsyjqftnvm))
- [To address this, we can combine prompt engineering (upstream of generation) and factual inconsistency guardrails (downstream of generation). For prompt engineering, techniques like CoT help reduce hallucination by getting the LLM to explain its reasoning before finally returning the output. Then, we can apply a](https://eugeneyan.com/writing/finetuning/) [factual inconsistency](https://eugeneyan.com/writing/finetuning/) guardrail to assess the factuality of summaries and filter or regenerate hallucinations. In some cases, hallucinations can be deterministically detected. When using resources from RAG retrieval, if the output is structured and identifies what the resources are, you should be able to manually verify they’re sourced from the input context. ([View Highlight](https://read.readwise.io/read/01hzzdmggm7n4by5phc1y64vbx))
- Just as the quality of ingredients determines the taste of a dish, the quality of input data constrains the performance of machine learning systems. In addition, output data is the only way to tell whether the product is working or not. All the authors focus on the data, looking at inputs and outputs for several hours a week to better understand the data distribution: its modes, its edge cases, and the limitations of models of it. ([View Highlight](https://read.readwise.io/read/01hzzdns79dtrrja8be39fcq3g))
- A common source of errors in traditional machine learning pipelines is train-serve skew. This happens when the data used in training differs from what the model encounters in production. Although we can use LLMs without training or finetuning, hence there’s no training set, a similar issue arises with development-prod data skew. Essentially, the data we test our systems on during development should mirror what the systems will face in production. If not, we might find our production accuracy suffering. ([View Highlight](https://read.readwise.io/read/01hzzdp5exrscha4gpjn1rzakm))
- LLM development-prod skew can be categorized into two types: structural and content-based. Structural skew includes issues like formatting discrepancies, such as differences between a JSON dictionary with a list-type value and a JSON list, inconsistent casing, and errors like typos or sentence fragments. These errors can lead to unpredictable model performance because different LLMs are trained on specific data formats, and prompts can be highly sensitive to minor changes. Content-based or “semantic” skew refers to differences in the meaning or context of the data. ([View Highlight](https://read.readwise.io/read/01hzzdprqdbdab84vtyy7ng1t6))
- As in traditional ML, it’s useful to periodically measure skew between the LLM input/output pairs. Simple metrics like the length of inputs and outputs or specific formatting requirements (e.g., JSON or XML) are straightforward ways to track changes. For more “advanced” drift detection, consider clustering embeddings of input/output pairs to detect semantic drift, such as shifts in the topics users are discussing, which could indicate they are exploring areas the model hasn’t been exposed to before. ([View Highlight](https://read.readwise.io/read/01hzzdq3e0sz35c5a7mp30a3ve))
- When testing changes, such as prompt engineering, ensure that hold-out datasets are current and rehect the most recent types of user interactions. For example, if typos are common in production inputs, they should also be present in the hold-out data. Beyond just numerical skew measurements, it’s beneficial to perform qualitative assessments on outputs. Regularly reviewing your model’s outputs—a practice colloquially known as “vibe checks”—ensures that the results align with expectations and remain relevant to user needs. Finally, incorporating nondeterminism into skew checks is also useful—by running the pipeline multiple times for each input in our testing dataset and analyzing all outputs, we increase the likelihood of catching anomalies that might occur only occasionally. ([View Highlight](https://read.readwise.io/read/01hzzdqnk032194c1ek52ewv3b))
- LLMs are dynamic and constantly evolving. Despite their impressive zero-shot capabilities and often delightful outputs, their failure modes can be highly unpredictable. For custom tasks, regularly reviewing data samples is essential to developing an intuitive understanding of how LLMs perform. ([View Highlight](https://read.readwise.io/read/01hzzdr71v24vx30793bzx7v97))
- Input-output pairs from production are the “real things, real places” (genchi genbutsu[) of LLM applications, and they cannot be substituted.](https://arxiv.org/abs/2404.12272) [Recent](https://arxiv.org/abs/2404.12272) research highlighted that developers’ perceptions of what constitutes “good” and “bad” outputs shift as they interact with more data (i.e., criteria drift). While developers can come up with some criteria upfront for evaluating LLM outputs, these predefined criteria are often incomplete. For instance, during the course of development, we might update the prompt to increase the probability of good responses and decrease the probability of bad ones. This iterative process of evaluation, reevaluation, and criteria update is necessary, as it’s difficult to predict either LLM behavior or human preference without directly observing the outputs. ([View Highlight](https://read.readwise.io/read/01hzzdtgq85gq090j1q9t0y1nw))
- To manage this effectively, we should log LLM inputs and outputs. By examining a sample of these logs daily, we can quickly identify and adapt to new patterns or failure modes. When we spot a new issue, we can immediately write an assertion or eval around it. Similarly, any updates to failure mode definitions should be rehected in the evaluation criteria. These “vibe checks” are signals of bad outputs; code and assertions operationalize them. Finally, this attitude must be socialized, for example by adding review or annotation of inputs and outputs to your on-call rotation. ([View Highlight](https://read.readwise.io/read/01hzzdtvkxbvbafaq6z1mr7czg))
- With LLM APIs, we can rely on intelligence from a handful of providers. While this is a boon, these dependencies also involve trade-offs on performance, latency, throughput, and cost. Also, as newer, better models drop (almost every month in the past year), we should be prepared to update our products as we deprecate old models and migrate to newer models. In this section, we share our lessons from working with technologies we don’t have full control over, where the models can’t be self-hosted and managed. ([View Highlight](https://read.readwise.io/read/01hzzdvarx0d44q2yz8kwavhhw))
- [For most real-world use cases, the output of an LLM will be consumed by a downstream application via some machine-readable format. For example,](https://www.youtube.com/watch?v=B_DMMlDuJB0) Rechat[, a real-estate CRM, required structured responses for the front end to render widgets. Similarly,](https://martinfowler.com/articles/building-boba.html) Boba[, a tool for generating product strategy ideas, needed structured output with fields for title, summary, plausibility score, and time horizon. Finally, LinkedIn shared about](https://www.linkedin.com/blog/engineering/generative-ai/musings-on-building-a-generative-ai-product) [constraining the LLM to generate](https://www.linkedin.com/blog/engineering/generative-ai/musings-on-building-a-generative-ai-product) YAML, which is then used to decide which skill to use, as well as provide the parameters to invoke the skill. ([View Highlight](https://read.readwise.io/read/01hzze1xrncd8xryz5z83e4zek))
- This application pattern is an extreme version of Postel’s Law: be liberal in what you accept (arbitrary natural language) and conservative in what you send (typed, machine-readable objects). As such, we expect it to be extremely durable. ([View Highlight](https://read.readwise.io/read/01hzze24a718n16masaek02b5j))
- [Currently,](https://github.com/jxnl/instructor) Instructor [and](https://github.com/outlines-dev/outlines) Outlines are the de facto standards for coaxing structured output from LLMs. If you’re using an LLM API (e.g., Anthropic, OpenAI), use Instructor; if you’re working with a self-hosted model (e.g., Huggingface), use Outlines. ([View Highlight](https://read.readwise.io/read/01hzze2srwgb367gxr8ztq1jzz))
- Sometimes, our carefully crafted prompts work superbly with one model but fall hat with another. This can happen when we’re switching between various model providers, as well as when we upgrade across versions of the same model. ([View Highlight](https://read.readwise.io/read/01hzze3atdma73cvs5wdst7b0j))
- [For example, Voicehow found that](https://www.voiceflow.com/blog/how-much-do-chatgpt-versions-affect-real-world-performance) [migrating from gpt-3.5-turbo-0301 to gpt-3.5-turbo-1106 led to a](https://www.voiceflow.com/blog/how-much-do-chatgpt-versions-affect-real-world-performance) 10% [](https://www.voiceflow.com/blog/how-much-do-chatgpt-versions-affect-real-world-performance)drop [in their intent classification task. (Thankfully, they had evals!) Similarly,](https://www.godaddy.com/resources/news/llm-from-the-trenches-10-lessons-learned-operationalizing-models-at-godaddy#h-3-prompts-aren-t-portable-across-models) [GoDaddy observed a trend](https://www.godaddy.com/resources/news/llm-from-the-trenches-10-lessons-learned-operationalizing-models-at-godaddy#h-3-prompts-aren-t-portable-across-models) in [](https://www.godaddy.com/resources/news/llm-from-the-trenches-10-lessons-learned-operationalizing-models-at-godaddy#h-3-prompts-aren-t-portable-across-models)[the positive](https://www.godaddy.com/resources/news/llm-from-the-trenches-10-lessons-learned-operationalizing-models-at-godaddy#h-3-prompts-aren-t-portable-across-models) direction, where upgrading to version 1106 narrowed the performance gap between gpt-3.5- turbo and gpt-4. (Or, if you’re a glass-half-full person, you might be disappointed that gpt-4’s lead was reduced with the new upgrade) ([View Highlight](https://read.readwise.io/read/01hzze3f0nbh7ycbkvcs65tm2m))
- Thus, if we have to migrate prompts across models, expect it to take more time than simply swapping the API endpoint. Don’t assume that plugging in the same prompt will lead to similar or better results. Also, having reliable, automated evals helps with measuring task performance before and after migration, and reduces the effort needed for manual verification. ([View Highlight](https://read.readwise.io/read/01hzze3j0nzrd7sfefwzdab8tn))
- [In any machine learning pipeline, “](https://papers.nips.cc/paper_files/paper/2015/hash/86df7dcfd896fcaf2674f757a2463eba-Abstract.html)[changing anything changes](https://papers.nips.cc/paper_files/paper/2015/hash/86df7dcfd896fcaf2674f757a2463eba-Abstract.html) everything”. This is particularly relevant as we rely on components like large language models (LLMs) that we don’t train ourselves and that can change without our knowledge. ([View Highlight](https://read.readwise.io/read/01hzze3qbezz5x622xa5dak1f8))
- Fortunately, many model providers offer the option to “pin” specific model versions (e.g., gpt-4-turbo- 1106). This enables us to use a specific version of the model weights, ensuring they remain unchanged. Pinning model versions in production can help avoid unexpected changes in model behavior, which could lead to customer complaints about issues that may crop up when a model is swapped, such as overly verbose outputs or other unforeseen failure modes. ([View Highlight](https://read.readwise.io/read/01hzze45p1crve7edhtn0781p2))
- Additionally, consider maintaining a shadow pipeline that mirrors your production setup but uses the latest model versions. This enables safe experimentation and testing with new releases. Once you’ve validated the stability and quality of the outputs from these newer models, you can confidently update the model versions in your production environment. ([View Highlight](https://read.readwise.io/read/01hzze47xhqkhc68zwajmsq7am))

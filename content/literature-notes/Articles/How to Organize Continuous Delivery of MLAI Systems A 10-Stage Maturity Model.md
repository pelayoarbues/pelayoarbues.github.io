---
author: [[The Outerbounds Team]]
title: "How to Organize Continuous Delivery of ML/AI Systems: A 10-Stage Maturity Model"
date: 2024-06-01
tags: 
- articles
- literature-note
---
![rw-book-cover](https://outerbounds.com/blog/og/continuous-delivery-of-ml-ai.jpg)

## Metadata
- Author: [[The Outerbounds Team]]
- Full Title: How to Organize Continuous Delivery of ML/AI Systems: A 10-Stage Maturity Model
- URL: https://outerbounds.com/blog/continuous-delivery-of-ml-ai/

## Highlights
- Every production-oriented ML/AI team grapples with the same challenge: how to work with data, code, and models effectively so that projects are readily deployable to production. ([View Highlight](https://read.readwise.io/read/01hz5k1yp7ne08q3qr2t09mn7y))
- he challenge is not new. If you ignore the data and models part, software engineers have been facing and addressing the challenge for decades. Best practices and processes for doing this effectively are often found under the moniker *Continuous Delivery* (CD) which is concisely defined at [continuousdelivery.com](https://continuousdelivery.com):
  > Continuous Delivery is the ability to get changes of all types—including new features, configuration changes, bug fixes and experiments—into production, or into the hands of users, *safely* and *quickly* in a sustainable way. ([View Highlight](https://read.readwise.io/read/01hz5k23jxam5wxsa2v16zw045))
- Consider these three core challenges that are endemic in ML, AI, and data projects:
  1. **Development and debugging cycles are more tedious** due to computational requirements of models and data processing. Specialized hardware like GPUs pose extra challenges for dependency management, cause tricky cross-platform issues, and create gaps between development and production environments.
  2. **Data introduces entropy** - systems that [deal with constantly changing data are less predictable](https://outerbounds.com/blog/mlops-vs-devops/), and hence [inherently harder to make reproducible and debuggable](https://outerbounds.com/docs/reproducible-ml/) than traditional software that has smaller surface area against the outside world.
  3. **It is hard to ascertain that ML/AI systems work correctly**. A key tenet of continuous delivery is to follow a process, such as rigorous testing and manual reviews, to ensure that changes don't cause breakage. In the case of ML/AI, ensuring correctness often [happens empirically over time after the deployment, not before](https://outerbounds.com/docs/versioning-code-and-models/):
  ![](https://outerbounds.com/assets/images/versioning-code-and-models-09554cc084df4cf7bbc7cc085d3c0769.png) ([View Highlight](https://read.readwise.io/read/01hz5k2tmf11jy8vp4myg3de46))
- We have observed problems, solutions, and best practices for CD at [hundreds of advanced ML/AI organizations that we have worked with](https://outerbounds.com/stories/). It is clear that every organization is different - there isn't a cookie-cutter approach that works as such for all - but the following four building blocks seem foundational in all successful CD implementations:
  0. **Embrace GitOps**: As a baseline, you should follow [all the existing GitOps best practices](https://about.gitlab.com/topics/gitops/) from pull requests to automated testing. When it comes to CD for ML/AI, this is necessary but not sufficient.
  1. **Scalable compute built-in, from prototype to production**: To address the compute requirements, we provide [compute-optimized cloud workstations](https://outerbounds.com/features/cloud-workstations/), coupled with [a scalable, multi-cloud compute backend](https://outerbounds.com/features/compute-at-scale/) out of the box - as well as solutions for [dependency management](https://outerbounds.com/blog/pypi-announcement/) and specialized hardware [like GPUs](https://outerbounds.com/blog/nvidia-cloud-gpu-announcement/) and [other accelerators](https://outerbounds.com/blog/trainium-metaflow/).
  2. **First-class support for data, artifacts, and change management**: To tame the entropy, Outerbounds provides various tools that help [dealing with real-world data securely](https://outerbounds.com/features/access-data/), as well as [managing state and change with minimal overhead](https://outerbounds.com/features/version-and-track/).
  3. **Isolated, flexible, secure environments**: Since one can't ascertain the quality and correctness of every model and deployment in advance, we make it possible [create isolated environments and deployments](https://outerbounds.com/features/security-and-compliance/) which allow you to [experiment safely and test new approaches](https://outerbounds.com/features/experiment-safely/) without interfering with production. This helps with compliance too in scenarios where production deployments are under high scrutiny, or projects must be kept isolated from each other. ([View Highlight](https://read.readwise.io/read/01hz5kbq2xw76rdg2m18esrw30))
- This is a familiar baseline in many ML/AI projects. You have a few developers, like Alex and Avery below, hacking code locally on their laptops or maybe cloud-based notebooks like [Google Colab](https://colab.research.google.com/) or [Amazon Sagemaker Studio](https://aws.amazon.com/sagemaker/studio/), accessing data from a common data store:
  ![](https://outerbounds.com/assets/images/stage-01-0b2b36a2af08129ff19d961b7590eca6.svg) ([View Highlight](https://read.readwise.io/read/01hz5kck04hjqtpdzf73gwnqjt))
- Notebooks are convenient for exploratory data analysis and as a quick scratchpad for code snippets. When it comes to developing production-ready code, it is beneficial to use a full-fledged IDE like VSCode, which allows you to develop modular, idiomatic Python projects - including [Metaflow flows](https://docs.metaflow.org/metaflow/basics) - while following GitOps best practices. ([View Highlight](https://read.readwise.io/read/01hz5kcxeq98c860t7mtxvfhgw))
- The Stage 1 resembles a typical setup in traditional software engineering: Developers hack code on their laptops, checking in code to Git periodically to keep track of changes. In projects involving ML, AI, and data improvements happen not only through changes in the code but also in changing data, models, and configuration. Keeping track of these changes and their impact becomes critical. ([View Highlight](https://read.readwise.io/read/01hz5kdw3afhp230e6gek73qxc))
- Many tools and services, such as [MLFlow](https://mlflow.org), [Weights and Biases](https://wandb.com), and [Comet](https://comet.com), have emerged to address this need, often categorized as *experiment tracking*. They provide a layer of metadata that keeps track of models, metrics, and other artifacts produced as Alex and Avery develop their projects:
  ![](https://outerbounds.com/assets/images/stage-02-f1feae371a6ee41938a005de2cd1e6d5.svg) ([View Highlight](https://read.readwise.io/read/01hz5ke3w3he1ngfwr4617n5hz))
- Since keeping track of code, data, models - as well as the state of systems in general - is such a fundamental part of ML/AI projects, it is beneficial to consider it as an integral part of the systems we build, not as a separate add-on.
  Metaflow takes this approach by recording, persisting, and [versioning the full state of the workflow automatically](https://outerbounds.com/features/version-and-track/), so you can observe any part of your system, not just models or specific pieces of data, consistently across experimentation and production, as shown in this quick example:
  As shown in the video, you can also present the data tracked through [custom, real-time visualizations](https://outerbounds.com/blog/metaflow-dynamic-cards/) which are easily viewable in the UI. ([View Highlight](https://read.readwise.io/read/01hz5kejpbcaxvw7ct7kwq7jns))
- What happens if Alex needs to load a dataframe that doesn't fit in the memory of their workstation, or Avery wants to fine-tune a set of LLMs on beefy GPUs? In scenarios like this, which are very common in ML/AI projects, developers need access to scalable compute resources outside their personal development environment - the more quickly and frictionlessly the better.
  ![](https://outerbounds.com/assets/images/stage-03-407a81aff950c6a4bc0c4178ac7677cc.svg) ([View Highlight](https://read.readwise.io/read/01hz5kfanbj6btmwc4m6fy91xb))
- In the past, ML developers and data scientists were often required to learn a new paradigm, rewrite their code, and move to a different set of libraries - say, to move from Python to Spark - to test things at scale, severely slowing down development cycles and creating a massive gap in the delivery process. ([View Highlight](https://read.readwise.io/read/01hz5kfghbhq49zqq9mh9mz8pm))
- Developers working concurrently can inadvertently interfere with each other's work. For instance, consider two experiments running in parallel, both writing results to the same file or a database table. ([View Highlight](https://read.readwise.io/read/01hz5kgpjj84rn2ejfjp1rkzyw))
- The challenge is amplified by shared compute pools, as workloads execute outside the confines of personal workstations. It is hard to achieve repeatable, worry-free continuous delivery, if there's a chance of developers stepping on each other's toes. Preferably, all developers would stay on their own swimlane by default - without fear of interference - while making it easy to collaborate whenever opportunities arise. ([View Highlight](https://read.readwise.io/read/01hz5kgwpp8yhejzx1pvyb99kd))
- Metaflow [organizes all data, code, and models automatically under namespaces](https://docs.metaflow.org/scaling/tagging). A developer can safely develop their code as if no other developers existed, but accessing a colleague's results is just a matter of switching the namespace:
  Besides namespaces, Metaflow allows you to [organize results with user-defined tags](https://outerbounds.com/blog/five-ways-to-use-the-new-metaflow-tags/) which make it possible to define various human-in-the-loop processes, for instance, to approve models before deployment. ([View Highlight](https://read.readwise.io/read/01hz5kt8m61j9s1f01czawnweb))
- The stages 1-4 ensure that developers are able to develop and test their projects, even at scale, and collaborate effectively. This establishes a robust foundation for *development* of production-grade ML/AI projects.
  An absolute requirement for *production deployments* are stable execution environments, that is, careful management of all software dependencies that are required to execute the code. Problems arise if there's a mismatch between the development and production environments. Preferably, one would use exactly the same environment from prototyping to production.
  A popular solution is to use container (Docker) images. This is a perfectly valid solution but it [brings up additional challenges](https://outerbounds.com/blog/pypi-announcement/):
  • Are data scientists and other developers supposed to maintain their own images? This is a non-trivial challenge by itself.
  • How to handle change management for images, say, Alex wants to update the version of `torch` (the yellow boxes in the image) but Avery wants to keep an older version (the orange boxes)?
  • What should be included in the image? Certainly it is not convenient to bake a new image every time the code or configuration changes.
  • How to manage the whole [software supply chain](https://www.chainguard.dev/unchained/good-mlops-is-good-ml-supply-chain-security), ensuring that images don't contain security vulnerabilities? ([View Highlight](https://read.readwise.io/read/01hz5ktyxde1k5by8ksj1t7m6d))
- To enable stable, consistent environments between development and production, without hindering the speed of iteration, Metaflow provides [built-in support for dependency management](https://docs.metaflow.org/scaling/dependencies). This video shows Metaflow's three main mechanisms for defining stable environments for cloud execution:
  Starting from the simplest pattern,
  1. Metaflow packages the user code automatically, including any custom modules and packages.
  2. It provides `@pypi` and `@conda` decorators which can be used to include 3rd party dependencies safely, without having to manage container images manually.
  3. Finally, to enable arbitrarily advanced cases, Metaflow allows you to use custom images - just specify `@kubernetes(image=)`. ([View Highlight](https://read.readwise.io/read/01hz5kvs2bc40cjjpdsmwerzs0))
- Stage 6: Deployments via CI/CD
  While one-click deployments are convenient, many organizations prefer to follow a more rigorous GitOps process where production deployments are done through a CI/CD system, such as GitHub Actions.
  ![](https://outerbounds.com/assets/images/stage-06-35ed64f13b1f3c6ede824cbbe2866061.svg)
  Using a CI/CD system provides a number of benefits over Stage 5: ([View Highlight](https://read.readwise.io/read/01hz5kw569xf7pvevqd3pxz5w5))
- • You can define arbitrary gates and policies, such as code reviews or automated tests, which must be passed before a deployment can commence.
  • Only the CI/CD system needs to access the production environment directly, making it more secure and protected from inadvertent actions.
  • You get a clear audit trail of deployments in the CI/CD system. ([View Highlight](https://read.readwise.io/read/01hz5kwbcwssqqk11w8wd9segz))
- This illustration outlines a typical path from development environment to production on Outerbounds, when including a CI/CD system like GitHub Actions:
  ![](https://outerbounds.com/assets/images/cicd-d0a5e03eb9bb7353722507950376c445.png) ([View Highlight](https://read.readwise.io/read/01hz5kyj04tcsbaafn9c2j381g))
- Crucially, the arrows 4 and 5, test execution and deployments, require GitHub Actions to communicate with the platform which is enabled via secure machine tokens. The beginning of this video shows how to set up GitHub Actions for Outerbounds, and the rest of the video goes through the path illustrated above:
  At this stage, you are able to
  1. Experiment locally, running code at scale if needed.
  2. Commit changes to GitHub, which triggers a test execution.
  3. If the test execution passes, the flow is deployed to production. ([View Highlight](https://read.readwise.io/read/01hz5kz45fz1w5ypnb353q08jm))
- Stage 6 is getting close to the continuous delivery nirvana. For small teams with a handful of projects it may be a perfectly sufficient setup.
  However, if your use cases are business or security-critical, the setup may be lacking, as experiments, tests, and production executions exist in the same environment with the same set of permissions. In particular, for data governance reasons you may need to limit access to production data only to production systems and let experiments access only test data. Or, you may want to limit the compute resources available to experimentation.
  ![](https://outerbounds.com/assets/images/stage-07-7595dd9ececcfb59edc57cec31508af6.svg) ([View Highlight](https://read.readwise.io/read/01hz5m0pe2n7dsn1dvz7yyzsg1))
- Outerbounds provides a core feature called *a perimeter* which allows you to create separate environments, such as staging and production, each with a different set of policies and permissions, like IAM permissions, container policies, and compute resources policies shown here:
  Through this mechanism, you can grant access to production tables, say in a Snowflake database, only to production perimeters, and let staging access other tables. Or, you can require that all container images used in production must come from a trusted registry. ([View Highlight](https://read.readwise.io/read/01hz5m11s7n6pphfkckm2ea3vs))
- A killer feature in many mature continuous delivery platforms, like [Vercel](https://vercel.com) that targets web applications, is the ability to create multiple parallel deployments, say, one for each pull request. This allows the developer to eyeball changes in a real environment before promoting their branch to production.
  As we mentioned in the beginning, ascertaining the quality of ML/AI branches is less straightforward - you can't just eyeball the results quickly. Instead, you may have to leave the branch running side-by-side with the current production, A/B testing the new version against the existing production version over time.
  ![](https://outerbounds.com/assets/images/stage-08-db80341fe5108edef5f7d21057923770.svg) ([View Highlight](https://read.readwise.io/read/01hz5m1jagybdvvg50jnjkwwh9))
- Stage 9: Isolated, secure environments
  In a large organization, it is not only Alex and Avery working on ML/AI but they have potentially hundreds of colleagues, spread across various lines of business. Each team is responsible for their own products and services, and hence they need their own isolated staging and production environments. In other words, the organization needs multiple copies of Stage 8, each with their own set up and policies.
  The organization may be distributed over multiple jurisdictions, so often it is critical that the environments are securely isolated from each other. To complicate things further, the teams may require different technical resources.
  For instance, in the illustration below, Blake and Casey may need the latest TPU accelerators from the Google Cloud for their compute vision project, whereas Alex and Avery use the company's main AWS account.
  ![](https://outerbounds.com/assets/images/stage-09-d4684c345eaa4a7a33feffa244a45e6d.svg) ([View Highlight](https://read.readwise.io/read/01hz5m2b683e6dgt7q0504eskc))
- Finally, what sets a trailblazing tech company like Netflix, Google, or Meta apart from other large organizations? Similar to any large organization, they have myriads of teams and products with diverse needs.
  They operate [massive-scale shared platforms](https://engineering.fb.com/2024/03/12/data-center-engineering/building-metas-genai-infrastructure/), compute in particular, on top of which each line of business can build solutions and workflows matching their requirements. This affords them benefits of scale, including higher utilization of compute resources in contrast to siloed deployments. As a result, the cost of compute is decreased and more resources can be made available to every team.
  ![](https://outerbounds.com/assets/images/stage-10-1b2edeb3949dcc003864dccc95bc9889.svg) ([View Highlight](https://read.readwise.io/read/01hz5m2qw0yqz2b4eawtba88nx))
